"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports._build = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(require("bluebird-lst"));
}

let _build = exports._build = (() => {
    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (options, cancellationToken = new (_builderUtilRuntime || _load_builderUtilRuntime()).CancellationToken()) {
        const packager = new (_packager || _load_packager()).Packager(options, cancellationToken);
        let electronDownloader = null;
        packager.electronDownloader = function (options) {
            if (electronDownloader == null) {
                electronDownloader = (_bluebirdLst2 || _load_bluebirdLst2()).default.promisify(require("electron-download-tf"));
            }
            return electronDownloader(options);
        };
        // because artifact event maybe dispatched several times for different publish providers
        const artifactPaths = new Set();
        packager.artifactCreated(function (event) {
            if (event.file != null) {
                artifactPaths.add(event.file);
            }
        });
        const publishManager = new (_electronBuilderLib || _load_electronBuilderLib()).PublishManager(packager, options);
        const sigIntHandler = function () {
            (_builderUtil || _load_builderUtil()).log.warn("cancelled by SIGINT");
            cancellationToken.cancel();
            publishManager.cancelTasks();
        };
        process.once("SIGINT", sigIntHandler);
        return yield (0, (_promise || _load_promise()).executeFinally)(packager.build().then(function () {
            return Array.from(artifactPaths);
        }), function (errorOccurred) {
            let promise;
            if (errorOccurred) {
                publishManager.cancelTasks();
                promise = (_bluebirdLst2 || _load_bluebirdLst2()).default.resolve(null);
            } else {
                promise = publishManager.awaitTasks();
            }
            return promise.then(function () {
                return process.removeListener("SIGINT", sigIntHandler);
            });
        });
    });

    return function _build(_x) {
        return _ref.apply(this, arguments);
    };
})();
/**
 * @private
 * @internal
 */


exports.normalizeOptions = normalizeOptions;
exports.coerceTypes = coerceTypes;
exports.createTargets = createTargets;
exports.build = build;
exports.configureBuildCommand = configureBuildCommand;

var _builderUtil;

function _load_builderUtil() {
    return _builderUtil = require("builder-util");
}

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = require("builder-util-runtime");
}

var _promise;

function _load_promise() {
    return _promise = require("builder-util/out/promise");
}

var _chalk;

function _load_chalk() {
    return _chalk = _interopRequireDefault(require("chalk"));
}

var _electronBuilderLib;

function _load_electronBuilderLib() {
    return _electronBuilderLib = require("electron-builder-lib");
}

var _packager;

function _load_packager() {
    return _packager = require("electron-builder-lib/out/packager");
}

var _deepAssign;

function _load_deepAssign() {
    return _deepAssign = require("read-config-file/out/deepAssign");
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @internal */
function normalizeOptions(args) {
    if (args.targets != null) {
        return args;
    }
    if (args.draft != null || args.prerelease != null) {
        (_builderUtil || _load_builderUtil()).log.warn({ solution: "set releaseType (http://electron.build/configuration/publish#GithubOptions-releaseType) in the GitHub publish options" }, "--draft and --prerelease is deprecated");
    }
    let targets = new Map();
    function processTargets(platform, types) {
        function commonArch(currentIfNotSpecified) {
            if (platform === (_electronBuilderLib || _load_electronBuilderLib()).Platform.MAC) {
                return args.x64 || currentIfNotSpecified ? [(_builderUtil || _load_builderUtil()).Arch.x64] : [];
            }
            const result = Array();
            if (args.x64) {
                result.push((_builderUtil || _load_builderUtil()).Arch.x64);
            }
            if (args.armv7l) {
                result.push((_builderUtil || _load_builderUtil()).Arch.armv7l);
            }
            if (args.ia32) {
                result.push((_builderUtil || _load_builderUtil()).Arch.ia32);
            }
            return result.length === 0 && currentIfNotSpecified ? [(0, (_builderUtil || _load_builderUtil()).archFromString)(process.arch)] : result;
        }
        if (args.platform != null) {
            throw new (_builderUtil || _load_builderUtil()).InvalidConfigurationError(`--platform cannot be used if --${platform.buildConfigurationKey} is passed`);
        }
        if (args.arch != null) {
            throw new (_builderUtil || _load_builderUtil()).InvalidConfigurationError(`--arch cannot be used if --${platform.buildConfigurationKey} is passed`);
        }
        let archToType = targets.get(platform);
        if (archToType == null) {
            archToType = new Map();
            targets.set(platform, archToType);
        }
        if (types.length === 0) {
            const defaultTargetValue = args.dir ? [(_electronBuilderLib || _load_electronBuilderLib()).DIR_TARGET] : [];
            for (const arch of commonArch(args.dir === true)) {
                archToType.set(arch, defaultTargetValue);
            }
            return;
        }
        for (const type of types) {
            const suffixPos = type.lastIndexOf(":");
            if (suffixPos > 0) {
                (0, (_builderUtil || _load_builderUtil()).addValue)(archToType, (0, (_builderUtil || _load_builderUtil()).archFromString)(type.substring(suffixPos + 1)), type.substring(0, suffixPos));
            } else {
                for (const arch of commonArch(true)) {
                    (0, (_builderUtil || _load_builderUtil()).addValue)(archToType, arch, type);
                }
            }
        }
    }
    if (args.mac != null) {
        processTargets((_electronBuilderLib || _load_electronBuilderLib()).Platform.MAC, args.mac);
    }
    if (args.linux != null) {
        processTargets((_electronBuilderLib || _load_electronBuilderLib()).Platform.LINUX, args.linux);
    }
    if (args.win != null) {
        processTargets((_electronBuilderLib || _load_electronBuilderLib()).Platform.WINDOWS, args.win);
    }
    if (targets.size === 0) {
        if (args.platform == null && args.arch == null) {
            processTargets((_electronBuilderLib || _load_electronBuilderLib()).Platform.current(), []);
        } else {
            targets = createTargets(normalizePlatforms(args.platform), args.dir ? (_electronBuilderLib || _load_electronBuilderLib()).DIR_TARGET : null, args.arch);
        }
    }
    const result = Object.assign({}, args);
    result.targets = targets;
    delete result.dir;
    delete result.mac;
    delete result.linux;
    delete result.win;
    delete result.platform;
    delete result.arch;
    const r = result;
    delete r.em;
    delete r.m;
    delete r.o;
    delete r.l;
    delete r.w;
    delete r.windows;
    delete r.macos;
    delete r.$0;
    delete r._;
    delete r.version;
    delete r.help;
    delete r.c;
    delete result.ia32;
    delete result.x64;
    delete result.armv7l;
    if (result.project != null && result.projectDir == null) {
        result.projectDir = result.project;
    }
    delete result.project;
    let config = result.config;
    const deprecatedExtraMetadata = r.extraMetadata;
    delete r.extraMetadata;
    // config is array when combining dot-notation values with a config file value (#2016)
    if (Array.isArray(config)) {
        const newConfig = {};
        for (const configItem of config) {
            if (typeof configItem === "object") {
                (0, (_deepAssign || _load_deepAssign()).deepAssign)(newConfig, configItem);
            } else if (typeof configItem === "string") {
                newConfig.extends = configItem;
            }
        }
        config = newConfig;
        result.config = newConfig;
    }
    if (deprecatedExtraMetadata != null) {
        if (typeof config === "string") {
            // transform to object and specify path to config as extends
            config = {
                extends: config,
                extraMetadata: deprecatedExtraMetadata
            };
            result.config = config;
        } else if (config == null) {
            config = {};
            result.config = config;
        }
        config.extraMetadata = deprecatedExtraMetadata;
    }
    if (config != null && typeof config !== "string") {
        if (config.extraMetadata != null) {
            coerceTypes(config.extraMetadata);
        }
        if (config.mac != null) {
            // ability to disable code sign using -c.mac.identity=null
            coerceValue(config.mac, "identity");
        }
    }
    return result;
}
function coerceValue(host, key) {
    const value = host[key];
    if (value === "true") {
        host[key] = true;
    } else if (value === "false") {
        host[key] = false;
    } else if (value === "null") {
        host[key] = null;
    } else if (key === "version" && typeof value === "number") {
        host[key] = value.toString();
    } else if (value != null && typeof value === "object") {
        coerceTypes(value);
    }
}
/** @private */
function coerceTypes(host) {
    for (const key of Object.getOwnPropertyNames(host)) {
        coerceValue(host, key);
    }
    return host;
}
function createTargets(platforms, type, arch) {
    const targets = new Map();
    for (const platform of platforms) {
        const archs = platform === (_electronBuilderLib || _load_electronBuilderLib()).Platform.MAC ? [(_builderUtil || _load_builderUtil()).Arch.x64] : arch === "all" ? [(_builderUtil || _load_builderUtil()).Arch.x64, (_builderUtil || _load_builderUtil()).Arch.ia32] : [(0, (_builderUtil || _load_builderUtil()).archFromString)(arch == null ? process.arch : arch)];
        const archToType = new Map();
        targets.set(platform, archToType);
        for (const arch of archs) {
            archToType.set(arch, type == null ? [] : [type]);
        }
    }
    return targets;
}
function build(rawOptions) {
    const options = normalizeOptions(rawOptions || {});
    if (options.cscLink === undefined && !(0, (_builderUtil || _load_builderUtil()).isEmptyOrSpaces)(process.env.CSC_LINK)) {
        options.cscLink = process.env.CSC_LINK;
    }
    if (options.cscInstallerLink === undefined && !(0, (_builderUtil || _load_builderUtil()).isEmptyOrSpaces)(process.env.CSC_INSTALLER_LINK)) {
        options.cscInstallerLink = process.env.CSC_INSTALLER_LINK;
    }
    if (options.cscKeyPassword === undefined && !(0, (_builderUtil || _load_builderUtil()).isEmptyOrSpaces)(process.env.CSC_KEY_PASSWORD)) {
        options.cscKeyPassword = process.env.CSC_KEY_PASSWORD;
    }
    if (options.cscInstallerKeyPassword === undefined && !(0, (_builderUtil || _load_builderUtil()).isEmptyOrSpaces)(process.env.CSC_INSTALLER_KEY_PASSWORD)) {
        options.cscInstallerKeyPassword = process.env.CSC_INSTALLER_KEY_PASSWORD;
    }
    // emoji doesn't improve output a lot, so, do not use it
    // if ((process.stdout as any).isTTY) {
    //   log.messageTransformer = (m, level) => {
    //     let separator = "  "
    //     let emoji: string | null = null
    //     if (level === "warn") {
    //       emoji = "warning"
    //     }
    //     else if (m === "packaging") {
    //       emoji = "package"
    //       separator = " "
    //     }
    //     else if (m === "building") {
    //       emoji = "building_construction"
    //     }
    //     else if (m === "uploading") {
    //       emoji = "rocket"
    //       separator = " "
    //     }
    //     return emoji == null ? m : `${getEmoji(emoji)}${separator}${m}`
    //   }
    // }
    return _build(options);
}
function configureBuildCommand(yargs) {
    const publishGroup = "Publishing:";
    const buildGroup = "Building:";
    const deprecated = "Deprecated:";
    return yargs.option("mac", {
        group: buildGroup,
        alias: ["m", "o", "macos"],
        description: `Build for macOS, accepts target list (see ${(_chalk || _load_chalk()).default.underline("https://goo.gl/5uHuzj")}).`,
        type: "array"
    }).option("linux", {
        group: buildGroup,
        alias: "l",
        description: `Build for Linux, accepts target list (see ${(_chalk || _load_chalk()).default.underline("https://goo.gl/4vwQad")})`,
        type: "array"
    }).option("win", {
        group: buildGroup,
        alias: ["w", "windows"],
        description: `Build for Windows, accepts target list (see ${(_chalk || _load_chalk()).default.underline("https://goo.gl/jYsTEJ")})`,
        type: "array"
    }).option("x64", {
        group: buildGroup,
        description: "Build for x64",
        type: "boolean"
    }).option("ia32", {
        group: buildGroup,
        description: "Build for ia32",
        type: "boolean"
    }).option("armv7l", {
        group: buildGroup,
        description: "Build for armv7l",
        type: "boolean"
    }).option("dir", {
        group: buildGroup,
        description: "Build unpacked dir. Useful to test.",
        type: "boolean"
    }).option("publish", {
        group: publishGroup,
        alias: "p",
        description: `Publish artifacts (to GitHub Releases), see ${(_chalk || _load_chalk()).default.underline("https://goo.gl/tSFycD")}`,
        choices: ["onTag", "onTagOrDraft", "always", "never", undefined]
    }).option("draft", {
        group: deprecated,
        description: "Please set releaseType in the GitHub publish options instead",
        type: "boolean",
        default: undefined
    }).option("prerelease", {
        group: deprecated,
        description: "Please set releaseType in the GitHub publish options instead",
        type: "boolean",
        default: undefined
    }).option("platform", {
        group: deprecated,
        description: "The target platform (preferred to use --mac, --win or --linux)",
        choices: ["mac", "win", "linux", "darwin", "win32", "all", undefined]
    }).option("arch", {
        group: deprecated,
        description: "The target arch (preferred to use --x64 or --ia32)",
        choices: ["ia32", "x64", "all", undefined]
    }).option("extraMetadata", {
        alias: ["em"],
        group: buildGroup,
        description: "Deprecated. Use -c.extraMetadata."
    }).option("prepackaged", {
        alias: ["pd"],
        group: buildGroup,
        description: "The path to prepackaged app (to pack in a distributable format)"
    }).option("projectDir", {
        alias: ["project"],
        group: buildGroup,
        description: "The path to project directory. Defaults to current working directory."
    }).option("config", {
        alias: ["c"],
        group: buildGroup,
        description: "The path to an electron-builder config. Defaults to `electron-builder.yml` (or `json`, or `json5`), see " + (_chalk || _load_chalk()).default.underline("https://goo.gl/YFRJOM")
    }).group(["help", "version"], "Other:").example("electron-builder -mwl", "build for macOS, Windows and Linux").example("electron-builder --linux deb tar.xz", "build deb and tar.xz for Linux").example("electron-builder --win --ia32", "build for Windows ia32").example("electron-builder --em.foo=bar", "set package.json property `foo` to `bar`").example("electron-builder --config.nsis.unicode=false", "configure unicode options for NSIS");
}
function normalizePlatforms(rawPlatforms) {
    const platforms = rawPlatforms == null || Array.isArray(rawPlatforms) ? rawPlatforms : [rawPlatforms];
    if (platforms == null || platforms.length === 0) {
        return [(_electronBuilderLib || _load_electronBuilderLib()).Platform.fromString(process.platform)];
    } else if (platforms[0] === "all") {
        if (process.platform === (_electronBuilderLib || _load_electronBuilderLib()).Platform.MAC.nodeName) {
            return [(_electronBuilderLib || _load_electronBuilderLib()).Platform.MAC, (_electronBuilderLib || _load_electronBuilderLib()).Platform.LINUX, (_electronBuilderLib || _load_electronBuilderLib()).Platform.WINDOWS];
        } else if (process.platform === (_electronBuilderLib || _load_electronBuilderLib()).Platform.LINUX.nodeName) {
            // macOS code sign works only on macOS
            return [(_electronBuilderLib || _load_electronBuilderLib()).Platform.LINUX, (_electronBuilderLib || _load_electronBuilderLib()).Platform.WINDOWS];
        } else {
            return [(_electronBuilderLib || _load_electronBuilderLib()).Platform.WINDOWS];
        }
    } else {
        return platforms.map(it => it instanceof (_electronBuilderLib || _load_electronBuilderLib()).Platform ? it : (_electronBuilderLib || _load_electronBuilderLib()).Platform.fromString(it));
    }
}
//# sourceMappingURL=builder.js.map